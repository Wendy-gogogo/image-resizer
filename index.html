<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Toolkit - Image & Audio Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/dist/lame.all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .canvas-container {
            position: relative;
            width: 240px;
            height: 296px;
            border: 1px solid #ddd;
            margin: 20px auto;
            cursor: grab;
        }
        .canvas-container.grabbing {
            cursor: grabbing;
        }
        #imageCanvas {
            background-color: white;
        }
        .slider-container {
            max-width: 400px;
            margin: 20px auto;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="max-w-4xl mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Media Toolkit</h1>
        
        <!-- 功能切换标签 -->
        <div class="flex justify-center mb-6 border-b">
            <button id="tabImage" class="tab-button px-6 py-3 font-medium text-blue-600 border-b-2 border-blue-600">Image Editor</button>
            <button id="tabAudio" class="tab-button px-6 py-3 font-medium text-gray-500 hover:text-gray-700">Audio Converter</button>
        </div>

        <!-- 图片编辑功能区 -->
        <div id="contentImage" class="tab-content active bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Image Editor (240×296 Canvas)</h2>
            <p class="text-gray-600 mb-4 text-center">Upload an image, drag to move, scale with wheel/slider, export as high-quality JPG</p>
            
            <!-- 图片上传 -->
            <div class="text-center mb-4">
                <input type="file" id="imageUpload" accept="image/*" class="mb-4">
                <button id="resetCanvas" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded mr-2">Reset Canvas</button>
            </div>
            
            <!-- 画布容器 -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="imageCanvas" width="240" height="296"></canvas>
            </div>
            
            <!-- 缩放控制 -->
            <div class="slider-container">
                <label for="scaleSlider" class="block text-gray-700 mb-2">Image Scale: <span id="scaleValue">100</span>%</label>
                <input type="range" id="scaleSlider" min="10" max="500" value="100" class="w-full">
            </div>
            
            <!-- 导出按钮 -->
            <div class="text-center mt-6">
                <button id="exportImage" class="px-6 py-3 bg-blue-600 text-white rounded hover:bg-blue-700">Export High-Quality JPG</button>
            </div>
        </div>

        <!-- 音频转换功能区 -->
        <div id="contentAudio" class="tab-content bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Audio Converter (to 44.1kHz 16-bit WAV)</h2>
            <p class="text-gray-600 mb-4 text-center">Upload any audio file (MP3, WAV, etc.) and convert to 44.1kHz 16-bit WAV</p>
            
            <!-- 音频上传 -->
            <div class="text-center mb-6">
                <input type="file" id="audioUpload" accept="audio/*" class="mb-4">
                <div id="audioInfo" class="text-gray-700 mb-4 hidden"></div>
                <div id="conversionProgress" class="text-gray-700 mb-4 hidden">Converting... Please wait</div>
            </div>
            
            <!-- 转换和下载按钮 -->
            <div class="text-center">
                <button id="convertAudio" class="px-6 py-3 bg-blue-600 text-white rounded hover:bg-blue-700 mb-4 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Convert Audio</button>
                <button id="downloadAudio" class="px-6 py-3 bg-green-600 text-white rounded hover:bg-green-700 hidden">Download WAV File</button>
            </div>
        </div>
    </div>

    <script>
        // -------------------------- 通用标签切换功能 --------------------------
        const tabImage = document.getElementById('tabImage');
        const tabAudio = document.getElementById('tabAudio');
        const contentImage = document.getElementById('contentImage');
        const contentAudio = document.getElementById('contentAudio');

        tabImage.addEventListener('click', () => {
            contentImage.classList.add('active');
            contentAudio.classList.remove('active');
            tabImage.classList.add('text-blue-600', 'border-b-2', 'border-blue-600');
            tabImage.classList.remove('text-gray-500');
            tabAudio.classList.add('text-gray-500');
            tabAudio.classList.remove('text-blue-600', 'border-b-2', 'border-blue-600');
        });

        tabAudio.addEventListener('click', () => {
            contentAudio.classList.add('active');
            contentImage.classList.remove('active');
            tabAudio.classList.add('text-blue-600', 'border-b-2', 'border-blue-600');
            tabAudio.classList.remove('text-gray-500');
            tabImage.classList.add('text-gray-500');
            tabImage.classList.remove('text-blue-600', 'border-b-2', 'border-blue-600');
        });

        // -------------------------- 图片编辑功能 --------------------------
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        const imageUpload = document.getElementById('imageUpload');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');
        const exportImage = document.getElementById('exportImage');
        const resetCanvas = document.getElementById('resetCanvas');

        let uploadedImage = null;
        let currentScale = 1.0;
        let imageX = 0;
        let imageY = 0;

        // 拖动相关变量
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let imageStartX = 0;
        let imageStartY = 0;

        // 初始化画布为白色
        function initCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            uploadedImage = null;
            scaleSlider.value = 100;
            currentScale = 1.0;
            scaleValue.textContent = '100';
            isDragging = false;
        }

        // 检查鼠标是否在图片范围内
        function isMouseOverImage(mouseX, mouseY) {
            if (!uploadedImage) return false;
            const scaledWidth = uploadedImage.width * currentScale;
            const scaledHeight = uploadedImage.height * currentScale;
            return (
                mouseX >= imageX &&
                mouseX <= imageX + scaledWidth &&
                mouseY >= imageY &&
                mouseY <= imageY + scaledHeight
            );
        }

        // 获取画布上的鼠标坐标（修正偏移）
        function getCanvasMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        // 加载上传的图片
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/')) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    // 初始位置居中
                    imageX = (canvas.width - img.width) / 2;
                    imageY = (canvas.height - img.height) / 2;
                    drawImageOnCanvas();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // 绘制图片到画布
        function drawImageOnCanvas() {
            // 清空画布（白底）
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (uploadedImage) {
                const scaledWidth = uploadedImage.width * currentScale;
                const scaledHeight = uploadedImage.height * currentScale;
                ctx.drawImage(uploadedImage, imageX, imageY, scaledWidth, scaledHeight);
            }
        }

        // -------------------------- 新增：拖动功能 --------------------------
        // 鼠标按下事件（开始拖动）
        canvas.addEventListener('mousedown', (e) => {
            if (!uploadedImage) return;
            
            const mousePos = getCanvasMousePos(e);
            // 只有点击在图片上才允许拖动
            if (isMouseOverImage(mousePos.x, mousePos.y)) {
                isDragging = true;
                canvasContainer.classList.add('grabbing');
                // 记录初始位置
                dragStartX = mousePos.x;
                dragStartY = mousePos.y;
                imageStartX = imageX;
                imageStartY = imageY;
            }
        });

        // 鼠标移动事件（拖动过程）
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !uploadedImage) return;
            
            const mousePos = getCanvasMousePos(e);
            // 计算偏移量
            const dx = mousePos.x - dragStartX;
            const dy = mousePos.y - dragStartY;
            // 更新图片位置
            imageX = imageStartX + dx;
            imageY = imageStartY + dy;
            // 重新绘制
            drawImageOnCanvas();
        });

        // 鼠标松开/离开事件（结束拖动）
        function endDrag() {
            if (isDragging) {
                isDragging = false;
                canvasContainer.classList.remove('grabbing');
            }
        }

        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('mouseleave', endDrag);

        // -------------------------- 新增：滚轮缩放功能 --------------------------
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // 阻止页面滚动
            if (!uploadedImage) return;

            const mousePos = getCanvasMousePos(e);
            // 计算缩放增量（每滚动一次调整5%）
            const scaleDelta = e.deltaY > 0 ? -0.05 : 0.05;
            const newScale = Math.max(0.1, Math.min(5.0, currentScale + scaleDelta)); // 限制缩放范围10%-500%
            
            // 计算缩放中心点（鼠标位置）的偏移，让缩放围绕鼠标位置进行
            const scaledWidth = uploadedImage.width * currentScale;
            const scaledHeight = uploadedImage.height * currentScale;
            const mouseXInImage = mousePos.x - imageX;
            const mouseYInImage = mousePos.y - imageY;
            
            // 计算新位置，保证鼠标位置相对图片不变
            imageX = mousePos.x - (mouseXInImage * newScale / currentScale);
            imageY = mousePos.y - (mouseYInImage * newScale / currentScale);
            
            // 更新缩放值
            currentScale = newScale;
            const scalePercent = Math.round(currentScale * 100);
            scaleSlider.value = scalePercent;
            scaleValue.textContent = scalePercent;
            
            // 重新绘制
            drawImageOnCanvas();
        }, { passive: false });

        // -------------------------- 原有：缩放条控制（同步更新） --------------------------
        scaleSlider.addEventListener('input', (e) => {
            const scalePercent = parseInt(e.target.value);
            currentScale = scalePercent / 100;
            scaleValue.textContent = scalePercent;
            drawImageOnCanvas();
        });

        // 导出高质量JPG
        exportImage.addEventListener('click', () => {
            if (!uploadedImage) {
                alert('Please upload an image first!');
                return;
            }
            // 导出高质量JPG（quality=1.0）
            const dataURL = canvas.toDataURL('image/jpeg', 1.0);
            const link = document.createElement('a');
            link.download = 'canvas-image-' + new Date().getTime() + '.jpg';
            link.href = dataURL;
            link.click();
        });

        // 重置画布
        resetCanvas.addEventListener('click', initCanvas);

        // 初始化画布
        initCanvas();

        // -------------------------- 音频转换功能 --------------------------
        const audioUpload = document.getElementById('audioUpload');
        const convertAudio = document.getElementById('convertAudio');
        const downloadAudio = document.getElementById('downloadAudio');
        const audioInfo = document.getElementById('audioInfo');
        const conversionProgress = document.getElementById('conversionProgress');

        let audioBuffer = null;
        let convertedWavBlob = null;

        // 修复音频解码的错误写法
        audioUpload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('audio/')) return;

            // 显示文件信息
            audioInfo.textContent = `Selected file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
            audioInfo.classList.remove('hidden');
            
            // 启用转换按钮
            convertAudio.disabled = false;

            try {
                // 正确的音频解码方式
                const audioContext = new AudioContext();
                const arrayBuffer = await file.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                alert('Failed to decode audio file: ' + error.message);
                convertAudio.disabled = true;
            }
        });

        // 转换音频为44.1kHz 16位WAV
        convertAudio.addEventListener('click', async () => {
            if (!audioBuffer) return;

            conversionProgress.classList.remove('hidden');
            convertAudio.disabled = true;

            try {
                // 转换为44.1kHz 16位WAV
                const wavBlob = await convertAudioToWav(audioBuffer);
                convertedWavBlob = wavBlob;

                // 显示下载按钮
                downloadAudio.classList.remove('hidden');
                conversionProgress.classList.add('hidden');
                alert('Audio conversion completed! You can now download the WAV file.');
            } catch (error) {
                conversionProgress.classList.add('hidden');
                alert('Error converting audio: ' + error.message);
                convertAudio.disabled = false;
            }
        });

        // 下载转换后的WAV
        downloadAudio.addEventListener('click', () => {
            if (!convertedWavBlob) return;
            saveAs(convertedWavBlob, 'converted-audio-' + new Date().getTime() + '.wav');
        });

        // 核心音频转换函数（44.1kHz 16位 WAV）
        function convertAudioToWav(audioBuffer) {
            return new Promise((resolve) => {
                const targetSampleRate = 44100;
                const numChannels = audioBuffer.numberOfChannels;

                // 重采样到44.1kHz
                const offlineContext = new OfflineAudioContext(
                    numChannels,
                    audioBuffer.duration * targetSampleRate,
                    targetSampleRate
                );
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineContext.destination);
                source.start();

                offlineContext.startRendering().then((renderedBuffer) => {
                    // 将音频数据转换为16位PCM格式
                    const interleaved = interleaveChannels(renderedBuffer);
                    const dataView = encodeWav(interleaved, targetSampleRate, numChannels);
                    const wavBlob = new Blob([dataView], { type: 'audio/wav' });
                    resolve(wavBlob);
                });
            });
        }

        // 交错音频通道（处理立体声）
        function interleaveChannels(buffer) {
            const numChannels = buffer.numberOfChannels;
            const length = buffer.length * numChannels;
            const result = new Float32Array(length);
            let index = 0;
            let channelIndex = 0;

            while (channelIndex < numChannels) {
                for (let i = 0; i < buffer.length; i++) {
                    result[index++] = buffer.getChannelData(channelIndex)[i];
                }
                channelIndex++;
            }
            return result;
        }

        // 编码为WAV格式（16位）
        function encodeWav(samples, sampleRate, numChannels) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            // WAV文件头
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM格式
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true); // 字节率
            view.setUint16(32, numChannels * 2, true); // 块对齐
            view.setUint16(34, 16, true); // 16位
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            // 将Float32音频数据转换为16位整数
            floatTo16BitPCM(view, 44, samples);

            return view;
        }

        // 辅助函数：写入字符串到DataView
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // 辅助函数：Float32转16位PCM
        function floatTo16BitPCM(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }
    </script>
</body>
</html>
